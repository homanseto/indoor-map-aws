## How csurf({ cookie: true }) Works (Deep Dive)

## Cookie Security: Regular vs. httpOnly Cookies

**Regular Cookie:**

- Set without `httpOnly: true`.
- JavaScript can read/write (`document.cookie`).
- Sent to server with every request.
- Use for non-sensitive data (e.g., UI theme).

**httpOnly Cookie:**

- Set with `httpOnly: true`.
- JavaScript cannot access (not in `document.cookie`).
- Sent to server with every request.
- Use for sensitive data (e.g., JWT, session ID).

**Pros and Cons Table:**

| Cookie Type | JS Access | XSS Safe | Use for Sensitive Data? | Pros                                  | Cons                       |
| ----------- | --------- | -------- | ----------------------- | ------------------------------------- | -------------------------- |
| Regular     | Yes       | No       | No                      | Can be used by frontend JS            | Vulnerable to XSS          |
| httpOnly    | No        | Yes      | Yes                     | Safer for auth/session, XSS-protected | Cannot be used by frontend |

**How to Decide:**

- Use httpOnly for authentication/session tokens and sensitive data.
- Use regular only for non-sensitive data needed by frontend JS.

---

## JWT Authentication: Deep Dive

**How JWT Token is Created (jwt.sign):**

- Backend calls `jwt.sign(payload, secret, options)` after successful login.
- Payload contains user info (e.g., id, userName, role).
- Secret is a strong, random string only the backend knows.
- Options can include `expiresIn` (e.g., "1d").
- Returns a JWT string.

**Why Use HTTP-Only Cookies for JWT?**

- Prevents JavaScript (and XSS attacks) from stealing your token.
- Browser sends the cookie automatically with every request to your backend.
- No need to manually add the token to headers in frontend code.

**How Backend Checks JWT Authentication (jwt.verify):**

- Reads the token from the cookie (`req.cookies.token`).
- Calls `jwt.verify(token, secret)`.
- If valid, returns the decoded payload (user info).
- If invalid/expired, throws an error (user is not authenticated).

**Example:**

```js
const token = jwt.sign(
  { id: user.id, userName: user.userName, role: user.role },
  process.env.JWT_SECRET,
  { expiresIn: "1d" }
);
res.cookie("token", token, {
  httpOnly: true,
  sameSite: "lax",
  maxAge: 24 * 60 * 60 * 1000,
});
```

**Pros and Cons of Using JWT:**

| Feature   | Pros                                         | Cons                                           |
| --------- | -------------------------------------------- | ---------------------------------------------- |
| Stateless | No server session storage needed             | Hard to revoke tokens before expiry            |
| Scalable  | Works well with distributed systems          | Token size can be large                        |
| Flexible  | Can include custom claims (user info, roles) | If secret is leaked, attacker can forge tokens |
| Security  | With httpOnly cookie, safe from XSS          | Needs CSRF protection if used in cookies       |

**Best Practice:**

- Store JWT in httpOnly cookie for authentication.
- Never use user passwords as JWT secret; use a strong, random value.
- Use CSRF protection for state-changing requests.
- Extract payload info (e.g., username) after verifying JWT in backend.

---

**CSRF Secret and Token Generation:**

- When a request hits a route protected by csurf, the middleware checks for a `_csrf` cookie.
- If the cookie does not exist, csurf generates a random secret and sets it as the value of the `_csrf` cookie.
- When you call `req.csrfToken()`, csurf uses the secret from the `_csrf` cookie to generate a CSRF token (using a secure algorithm).
- The CSRF token is sent to the frontend (e.g., in a JSON response from `/api/account/csrf-token`).
- The browser automatically stores the `_csrf` cookie from the response header.

**Frontend Usage:**

- The frontend stores the CSRF token in a JS variable.
- For every POST/PUT/DELETE request, the frontend includes the token in the `X-CSRF-Token` header.
- The browser automatically sends the `_csrf` cookie with the request.

**Backend Validation:**

- On a protected request, csurf:
  - Reads the secret from the `_csrf` cookie.
  - Reads the token from the `X-CSRF-Token` header (or body/query).
  - Uses the same algorithm to check if the token is valid for the secret in the cookie.
  - If valid, the request is allowed. If not, a 403 error is returned.

**Is the Token Stored in the Backend?**

- No. The backend does not store the token. Only the secret (in the cookie) is needed. The token is always generated and validated on the fly using the secret and a secure algorithm.

**Summary:**

- `csurf({ cookie: true })` stores the CSRF secret in a cookie.
- The CSRF token is generated by the backend and sent to the frontend (not stored in the cookie).
- The frontend sends the token in a header; the browser sends the cookie automatically.
  **Key Point:**
  Always place authentication-protected routes (e.g., `/`, `/indoor-viewer.html`) _before_ `express.static` middleware in your Express app. If you put `app.use(express.static(...))` first, Express will serve static files directly and bypass any authentication or custom logic for those routes.
- By placing your protected routes above, you ensure that authentication is checked before serving the file.

**Example:**

````js
// Correct order:
app.get("/indoor-viewer.html", requireAuth, (req, res) => {
  res.sendFile(path.resolve("public/indoor-viewer.html"));
});


- Unauthenticated users are always redirected to `/login.html`, even if they try to access `/indoor-viewer.html` directly.
### csurf Middleware, Dummy Middleware, and Route Protection (Deep Dive)

**How csurf Works:**

- csurf checks for a valid CSRF token on all POST, PUT, DELETE, etc. requests with content types:
  - application/x-www-form-urlencoded
  - multipart/form-data
  - application/json
- If the token is missing or invalid, csurf throws an error and your route handler is never called.

**Dummy Middleware (e.g., app.use('/api/test/external-protected', (req, res, next) => next());):**


**Why Some Routes 'Work' Without a CSRF Token:**

- If you send a POST request without a Content-Type, or with a type not in csurf's default list, csurf may not check the request.
- If you send a GET request, csurf does not check for a CSRF token.
- If the body parser does not parse the body (e.g., missing Content-Type), csurf may not be triggered.

**apiKeyAuth and CSRF:**

- apiKeyAuth is just another middleware. It does NOT bypass csurf. If csurf throws an error, your handler (and apiKeyAuth) will not be called.

- Use a conditional wrapper to apply csurf only to routes that need it. Example:
  ```js
  app.use((req, res, next) => {
    if (
      req.path === "/api/test/external-protected"
    ) {
    return csrfProtection(req, res, next);
  });
````

**Summary Table:**

| Route                           | Dummy Middleware | apiKeyAuth | csurf Applied? | Handler Accesses req.csrfToken()? | CSRF Error if No Token? |
| ------------------------------- | ---------------- | ---------- | -------------- | --------------------------------- | ----------------------- |
| /api/admin/create-initial-admin | Yes              | No         | Yes            | No                                | Yes                     |

**Purpose:** Prevents cross-site request forgery attacks on browser-based POST/PUT/DELETE requests.

```js
// ...existing code...
// CSRF protection for browser routes
app.use(
  csurf({
    cookie: true, // Use cookie-based tokens (recommended for browser forms)
  })
);
```

3. **Excluding API Endpoints:**
   - To allow server-to-server POSTs (e.g., `/api/test/external-protected`), exclude these routes from CSRF protection.
   - Example (in `app.js`):
     ```js
     // Exclude API endpoints from CSRF
     app.use("/api/test/external-protected", (req, res, next) => next());
     // Then apply csurf middleware
     ```
   - Or, use conditional logic to skip CSRF for API key-protected endpoints.
     **How it works:**

- For browser users: CSRF token is set in a cookie and must be included in POST/PUT/DELETE requests (usually as a hidden form field or custom header).

**Best Practice:**

- Protect all browser-facing routes with CSRF.
- Exclude machine-to-machine API endpoints that use API keys or other non-browser authentication.

**References:**

- [Express csurf documentation](https://www.npmjs.com/package/csurf)

**Security Summary:**

- Cookie-based CSRF for browser users.
- API key in header for server-to-server POSTs (no CSRF required).
- This setup is secure and recommended for most full-stack apps.

## Express Static File Serving and Middleware Notes

### express.static vs. app.get("/")

- `app.use(express.static(path.resolve("public")));`

  - Serves all static files (HTML, JS, CSS, images, etc.) from the public directory.
  - Any request to `/filename` will return `public/filename` if it exists.
  - Example: `GET /style.css` → `public/style.css`

- `app.get("/", (req, res) => { res.sendFile(path.resolve("public/indoor-viewer.html")); });`
  - Serves a specific file (indoor-viewer.html) when the root URL (`/`) is requested.
  - Example: `GET /` → `public/indoor-viewer.html`

**Best Practice:**
Keep both. Use `express.static` for all assets, and use `app.get("/")` to ensure the root URL always loads your main app page (especially if it’s not named index.html).

### Public Directory Accessibility

- All files in the `public/` directory are accessible to anyone visiting your site.
- This is standard for web apps: browsers must download these files to display your site.
- Never put sensitive information (API keys, passwords, server-side code) in the public directory or frontend code.

### express.urlencoded Middleware

- `app.use(express.urlencoded({ extended: false }));`
  - Parses URL-encoded form data (from HTML forms with `method="POST"` and `enctype="application/x-www-form-urlencoded"`).
  - Not required for serving static files or loading your frontend.
  - Only needed if your backend processes form submissions.
  - Safe to remove if you do not use URL-encoded forms in your app.

### express

## API Key Middleware (Backend)

1. Add your API key to `.env`:
   ```
   API_KEY=your-strong-api-key-here
   ```
2. The middleware checks for the API key in the `x-api-key` header, `api_key` query param, or `api_key` in the POST body.
3. Example usage in backend route:
   ```js
   import { apiKeyAuth } from "../middleware/apiKeyAuth.js";
   router.post("/external-protected", apiKeyAuth, (req, res) => {
     res.json({ message: "API key authentication successful!" });
   });
   ```
4. To call a protected endpoint, clients must include the API key:

   - In header: `x-api-key: your-strong-api-key-here`
   - Or as query param: `?api_key=your-strong-api-key-here`
   - Or in POST body: `{ "api_key": "your-strong-api-key-here" }`

5. Middleware
   Middleware functions are the core of Express. They process requests before they reach your route handlers (e.g., logging, parsing JSON, authentication).
   In app.js, you’ll see lines like app.use(express.json()) or app.use(express.static('public')).
6. Routing
   Express uses routers to organize endpoints. In app.js, you’ll see app.use('/', indexRouter) and app.use('/users', usersRouter).
   You can modularize routes by creating separate router files.
7. Error Handling
   Express has a special error-handling middleware (with four arguments: err, req, res, next).
   The default generator includes a catch-all 404 handler and a general error handler.
8. Static Files
   The public directory is served as static files (CSS, JS, images, HTML) using express.static.
9. View Engines
   If you use dynamic templates (Pug/Jade, EJS, etc.), the view engine is set up in app.js and templates are stored in the views directory.
10. Environment Variables
    Use environment variables (like process.env.PORT) for configuration, especially in production.
11. Separation of Concerns
    app.js is for application logic (routes, middleware, config).
    www.js is for server/network logic (starting the server, handling errors at the server level).
12. Security and Production Readiness
    For real-world apps, consider adding security middleware (like helmet), request logging (morgan), and proper error handling.

### Docker

## Dockerfile:

1. Dockerfile (for web)
   FROM node:20: Uses the official Node.js 20 image as the base.
   WORKDIR /usr/app: Sets the working directory inside the container.
   COPY package.json ./\*: Copies package.json and package-lock.json for dependency installation.
   RUN npm install --production: Installs only production dependencies.
   COPY . .: Copies the rest of your app’s code into the container.
   EXPOSE 3000: Documents that the app listens on port 3000 (for Docker networking).
   CMD [ "npm", "start"]: The default command to run your app.

## Volumes:

Volumes persist data even if the container is stopped, removed, or recreated. Volumes are the preferred way to store database files, uploads, logs, and other persistent data in Docker. Volumes can be managed by Docker (named volumes) or mapped to a specific path on the host (bind mounts).
What: Persistent storage managed by Docker, independent of the container lifecycle.
Why: Keeps your database data safe if you rebuild, restart, or remove containers.
With volumes: Data persists across container restarts/rebuilds.
Without volumes: Data is lost when the container is removed.
Pros: Data safety, easy backup/restore, no accidental data loss.
Cons: Slightly more setup, but essential for real apps.

Named Volume:

> What happens:
> Docker manages the storage location for you (usually under /var/lib/docker/volumes on Linux, or in a special location on Mac/Windows).
> Data persists:
> Data in a named volume is not deleted when you recreate or restart containers with docker-compose up -d.
> Data is only deleted if you explicitly remove the volume (e.g., with docker-compose down -v or docker volume rm).
> Docker does NOT create a folder for a named volume in your project directory.
> Named volumes are managed internally by Docker, not as visible folders in

Bind Mount:

> What happens:
> You specify an exact folder on your host machine (e.g., ./mongo-data:/data/db).
> Data persists:
> Data is stored in that host folder and is never deleted by Docker unless you manually delete the folder.
> Bind mounts do create or use a folder you specify on your host.

Networks:
What: Isolated virtual networks for containers to communicate securely.
Why: Controls which containers can talk to each other, and how.
With a custom network: Only containers on the same network can communicate; others are isolated.
Without a custom network: All containers are on the default network, which may be less secure or organized.
Pros: Security, organization, prevents accidental exposure.
Cons: Slightly more setup, but best practice for multi-service apps.

### run and debug

**Key Concerns and Important Points for Creating a Debug Config File in VS Code:**

- Always specify the correct entry point for your server (e.g., `server/bin/www` for Express apps).
- Use the `envFile` property to load environment variables from your `.env` file for local development.
- Set `NODE_ENV` to `development` in your debug config to enable dev-specific features and logging.
- For full-stack (compound) debugging, define a `compounds` section to launch both backend and frontend debuggers together.
- If debugging the frontend (e.g., with Chrome), ensure the `url` and `webRoot` match your app's served location and source files.
- Use breakpoints in both backend and frontend code to step through requests end-to-end.
- Make sure your ports in the debug config match those exposed by Docker or your dev server.
- For TypeScript or transpiled projects, set `outFiles` to help VS Code map breakpoints to the correct files.
- Keep sensitive data (like passwords) out of your debug config; use environment variables instead.
- Document each configuration in `launch.json` for clarity, especially if working in a team.

**Example launch.json snippet for Node.js server:**

```json
{
  "type": "node",
  "request": "launch",
  "name": "Debug Server",
  "program": "${workspaceFolder}/server/bin/www",
  "envFile": "${workspaceFolder}/.env",
  "env": {
    "NODE_ENV": "development"
  }
}
```

**Example compound config:**

```json
{
  "compounds": [
    {
      "name": "Full Stack Debug",
      "configurations": ["Debug Server", "Debug Frontend"]
    }
  ]
}
```

## Why Separate www.js and app.js in Express

## Static File Serving, Public vs. Protected Assets (Deep Dive)

### What does app.use(express.static(path.resolve("public"))) do?

- Makes all files in the public directory (JS, CSS, images, etc.) available to anyone visiting your site.
- Browsers need this to load styles, scripts, and images for your login page and app.

### Example: With express.static

- /public/js/login.js → accessible at http://domain/js/login.js
- /public/style.css → accessible at http://domain/style.css

### Example: Without express.static

- Only routes you define (like app.get("/", ...)) will work.
- JS, CSS, and images will NOT load—your app will look broken.

### Protecting HTML vs. Static Assets

- You protect sensitive HTML pages (like / and /indoor-viewer.html) with requireAuth and custom routes.
- Static assets (JS, CSS, images) are public by default—this is normal for web apps.

### Can you protect static files?

- Yes, but you must remove them from public and serve them with a custom route + authentication middleware.
- Example:
  ```js
  app.get("/js/demo-main.js", requireAuth, (req, res) => {
    res.sendFile(path.resolve("public/js/demo-main.js"));
  });
  ```
- Only do this if the file contains sensitive logic (rare for frontend JS).

### Best Practices

- Never put secrets or sensitive logic in frontend JS—anything public can be seen by anyone.
- Keep express.static for assets needed by login and app pages.
- Protect only what truly needs to be hidden (HTML, API routes, etc.).

### Summary Table

| Asset Type      | Public by Default | How to Protect?          |
| --------------- | ----------------- | ------------------------ |
| JS/CSS/Images   | Yes               | Serve with route + auth  |
| HTML (main app) | No (if routed)    | Use requireAuth on route |
| API endpoints   | No                | Use auth middleware      |

**In your project:**

- / and /indoor-viewer.html are protected (require login).
- JS, CSS, and images are public (needed for login page and app to work).
- Only protect static files if they contain sensitive logic (rare).

**Best Practice:**

- `app.js` contains application logic: middleware, routes, configuration. It defines the Express app but does not start the server.
- `www.js` handles server/network logic: creates the HTTP server, listens on a port, manages low-level errors, and can be customized for different environments.

**Benefits:**

- Clean separation of concerns: `app.js` is reusable (for tests, CLI, etc.), `www.js` is only for starting the server.
- Easier testing: You can import `app.js` in tests without starting the server.
- Flexibility: You can use the same `app.js` for different entry points (e.g., HTTP, HTTPS, serverless).
- Follows Express generator and community conventions.

**Summary:**
Yes, it is good practice. Keep `app.js` for app logic, `www.js` for server startup.
